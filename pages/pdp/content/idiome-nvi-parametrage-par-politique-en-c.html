<!DOCTYPE html>
<html lang="fr" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Idiome NVI & Paramétrage par politique en C++ - The Golden Koala</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <link href="https://yliesc.github.io/images/koala-ico.png" rel="icon">

<link rel="canonical" href="https://yliesc.github.io/pages/pdp/content/idiome-nvi-parametrage-par-politique-en-c/">

        <meta name="author" content="Höd" />
        <meta name="description" content="Introduction &amp; Motivations Cet article, sur le C++, vise à présenter d&#39;une part l&#39;idiome NVI, pour « Non Virtual Interface », et d&#39;autre part, une technique de conception développée par Andreï Alexandrescu, notamment présentée dans son livre Modern C++ Design, à savoir le paramétrage pas politique. Le choix de présenter au sein du …" />

    <meta property="og:site_name" content="The Golden Koala" />
    <meta property="og:type" content="article"/>
    <meta property="og:title" content="Idiome NVI &amp; Paramétrage par politique en C++"/>
    <meta property="og:url" content="https://yliesc.github.io/pages/pdp/content/idiome-nvi-parametrage-par-politique-en-c/"/>
    <meta property="og:description" content="Introduction &amp; Motivations Cet article, sur le C++, vise à présenter d&#39;une part l&#39;idiome NVI, pour « Non Virtual Interface », et d&#39;autre part, une technique de conception développée par Andreï Alexandrescu, notamment présentée dans son livre Modern C++ Design, à savoir le paramétrage pas politique. Le choix de présenter au sein du …" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://yliesc.github.io/theme/css/bootstrap.readable.min.css" type="text/css"/>
    <link href="https://yliesc.github.io/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://yliesc.github.io/theme/css/pygments/default.css" rel="stylesheet">
    <link href="https://yliesc.github.io/theme/tipuesearch/tipuesearch.css" rel="stylesheet">
    <link rel="stylesheet" href="https://yliesc.github.io/theme/css/style.css" type="text/css"/>
        <link href="https://yliesc.github.io/css/custom.css" rel="stylesheet">

        <link href="https://yliesc.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="The Golden Koala ATOM Feed"/>




</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://yliesc.github.io/" class="navbar-brand">
<img class="img-responsive pull-left gap-right" src="https://yliesc.github.io/images/koala-logo.svg" width="38"/> <span id="siteName">The Golden Koala</span>            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">

            </ul>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <ol class="breadcrumb">
        <li><a href="https://yliesc.github.io/" title="The Golden Koala">
            <i class="fa fa-home fa-lg"></i>
        </a></li>
        <li class="active">Idiome NVI & Paramétrage par politique en C++</li>
    </ol>
    <section id="content" class="body">
        <h1 class="entry-title">Idiome NVI & Paramétrage par politique en C++</h1>
            <div class="entry-content">
                    <div class="panel">
                        <div class="panel-body">
<footer class="post-info">
    
    <span class="published">
        <span class="label label-default"><i class="fa fa-calendar"></i><time datetime="2015-01-23T00:00:00+01:00"> ven. 23 janvier 2015</time></span> | 
    </span>
        <span class="label label-default"><i class="fa fa-user-circle"></i> Höd</span>  | 
    <span class="label label-default">
            <i class="fa fa-cc"></i> 
        
            CC-BY-SA
    </span>
</footer><!-- /.page-info -->                        </div>
                    </div>
            <h3 id="introduction-motivations">Introduction &amp; Motivations</h3>
<p>Cet article, sur le C++, vise à présenter d'une part l'idiome NVI, pour « Non Virtual Interface », et d'autre part, une technique de conception développée par Andreï Alexandrescu, notamment présentée dans son livre Modern C++ Design, à savoir le paramétrage pas politique. <br />
Le choix de présenter au sein du même article un idiome et une méthode plus générale d'architecture logicielle est motivé par le fait que la combinaison des deux permet de produire du code robuste, plus spécifiquement destiné à être réutilisé (notamment dans le cadre d'un framework ou d'une bibliothèque).    </p>
<p>Dans un premier temps nous aborderons l'idiome NVI, ses applications et sa mise en place. Ensuite, nous verrons ce qu'est le paramétrage par politique et la manière d'identifier des comportements transversaux au sein d'un ensemble de classes.
Enfin, nous mettrons en application la combinaison des deux techniques afin de produire du code tirant bénéfice de ces deux techniques.</p>
<p>Dans la suite de l'article on se placera dans une situation générale où l'on écrit du code dit « service », pour un client qui écrira du code dit « client ».</p>
<div class="toc">
<ul>
<li><a href="#introduction-motivations">Introduction &amp; Motivations</a></li>
<li><a href="#lidiome-nvi">L'idiome NVI</a><ul>
<li><a href="#violation-du-srp">Violation du SRP</a></li>
<li><a href="#programmation-par-contrat">Programmation par contrat</a></li>
<li><a href="#inversion-de-controle">Inversion de contrôle</a></li>
<li><a href="#ce-quil-faut-retenir">Ce qu'il faut retenir</a></li>
<li><a href="#un-mot-sur-patron-de-methode">Un mot sur Patron de Méthode</a></li>
</ul>
</li>
<li><a href="#parametrage-par-politiques">Paramétrage par politiques</a><ul>
<li><a href="#presentation">Présentation</a></li>
<li><a href="#identification-des-politiques">Identification des politiques</a></li>
<li><a href="#mise-en-place">Mise en place</a></li>
</ul>
</li>
<li><a href="#combiner-les-deux-techniques">Combiner les deux techniques</a><ul>
<li><a href="#limitation-du-type-de-politique">Limitation du type de politique</a></li>
</ul>
</li>
<li><a href="#une-alternative">Une alternative</a></li>
<li><a href="#allez-plus-loin-politique-de-base-a-la-construction-logicielle">Allez plus loin : politique de base à la construction logicielle</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
</div>
<h3 id="lidiome-nvi">L'idiome NVI</h3>
<h4 id="violation-du-srp">Violation du SRP</h4>
<p>Une façon classique de considérer une interface est la suivante :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InterfaceService</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">service</span><span class="p">();</span> <span class="c1">// Eventuellement virtuel pur</span>
<span class="p">};</span>
</pre></div>


<p>Une classe concrète pourra ou devra (selon ce que propose l'interface) réimplémenter le service de la sorte :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MonService</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceService</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span> 
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">service</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Implémentation de mon service }</span>
<span class="p">};</span>
</pre></div>


<p>Cette approche très utilisée en Java notamment propose un désavantage de taille. En effet, en procédant de la sorte, nous donnons deux responsabilités à la classe concrète MonService :</p>
<ul>
<li>L'implémentation du service</li>
<li>La réalisation du service</li>
</ul>
<p>Ceci est donc une violation du « Single responsibility principle » qui veut que chaque objet ne se voit accorder qu'une unique responsabilité (et que cette responsabilité doit être complètement encapsulée par cette classe).</p>
<p>Aidons-nous de ce petit exemple de code client pour mieux comprendre :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">InterfaceService</span><span class="o">&amp;</span> <span class="n">_serveur</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_serveur</span><span class="p">.</span><span class="n">service</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">MonService</span> <span class="n">s</span><span class="p">;</span>

    <span class="n">a</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>On voit très clairement que le code client s'adresse directement à MonService malgré le fait qu'il manipule InterfaceService. Enfin, le service est réalisé par MonService, ce qui semble légitime.  <br />
La mauvaise distribution des responsabilités au sein d'une architecture est source de rigidité et va donc à l'encontre de la ré-utilisabilité et augmente la maintenance par une complexification du code.</p>
<h4 id="programmation-par-contrat">Programmation par contrat</h4>
<p>L'idiome NVI permet de distribuer ces responsabilités par la définition d'un contrat entre l'Interface et la classe concrète : l'Interface se charge de la vérification des invariants et préconditions sur le service et en contrepartie, la classe concrète se charge d'implémenter le service concret.</p>
<p>Voici l'implémentation de l'idiome :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InterfaceService</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="kt">void</span> <span class="n">service</span><span class="p">();</span> <span class="c1">// Notez la non-virtualité</span>

<span class="k">private</span> <span class="o">:</span> <span class="c1">// Notez le private</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_service</span><span class="p">();</span> <span class="c1">// Eventuellement virtuel pur</span>
<span class="p">};</span>

<span class="n">InterfaceService</span><span class="o">::</span><span class="n">service</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Préconditions &amp; invariants</span>
    <span class="c1">// ...</span>

    <span class="n">_service</span><span class="p">();</span>

    <span class="c1">// Postconditions &amp; invariants</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>


<p>Contrairement à la première approche, ici c'est bien InterfaceService::service qui sera appelé par le code client et qui lui même appellera l'implémentation du service (soit celle qu'il propose par défaut, soit celle redéfinie par la classe concrète MonService).   </p>
<h4 id="inversion-de-controle">Inversion de contrôle</h4>
<p>On a ici une vraie séparation des responsabilités en plus d'une factorisation du code appréciable : les préconditions et postconditions sont réalisées à un unique endroit : dans l'interface, c'est à dire dans le code service. <br />
Au delà du respect du SRP, cela permet également de centraliser en un endroit les préconditions relatives au contrat d'appel entre le code client et le code service : après tout, le never trust user inputs s'applique également avec un client. Qui nous garantit que si le client écrit une classe héritant de InterfaceService, il pensera à vérifier les invariants nécessaires au bon fonctionnement de la classe ?</p>
<p>En fait, le NVI permet une inversion de contrôle, caractéristique d'un framework : c'est le code service qui va appeler le code client et non l'inverse comme c'est le cas avec une simple bibliothèque. La différence est qu'ici, cette inversion de contrôle a une granularité très fine puisqu'elle est à l'échelle d'une classe, là où elle est généralement à l'échelle du flux d'exécution pour un framework. Cette inversion de contrôle permet de mieux faire face à la hantise du designer : le Fragile Base Class problem.    </p>
<p>Ce qui permet de réaliser cette inversion de contrôle est non seulement l'appel à l'implémentation du service par l'interface mais aussi et surtout l'encapsulation de l'implémentation du service dont la visibilité est privée dans l'interface, ce qui fait qu'elle sera impossible à appeler depuis la classe concrète du fait de sa virtualité.
On s'assure alors que le code client n’appellera jamais le code service.</p>
<p>Dans de très rares occasions, cela peut cependant être utile de procéder de la sorte. Pour cela, il est toujours possible de définir la méthode _service avec une visibilité en protégée, ce qui permettra au code client d'appeler l'implémentation par défaut :</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">InterfaceService</span> <span class="c1">// Évidemment on ne devrait avoir d&#39;un seul service, ceci est juste pour l&#39;exemple !</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="kt">void</span> <span class="n">service</span><span class="p">();</span>

<span class="k">protected</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_service</span><span class="p">();</span>

<span class="k">private</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_service2</span><span class="p">();</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MonService</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceService</span>
<span class="p">{</span> 
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_service</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">InterfaceService</span><span class="o">::</span><span class="n">_service</span><span class="p">();</span> <span class="c1">// OK</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_service2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">InterfaceService</span><span class="o">::</span><span class="n">_service2</span><span class="p">();</span> <span class="c1">// ERROR</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="ce-quil-faut-retenir">Ce qu'il faut retenir</h4>
<p>NVI aide à localiser les invariants à un unique endroit permettant de prévenir ou sécuriser le code client quand à la consistance de ces invariants. L'inversion de contrôle permet de respecter le Single Responsability Principle et de mieux maîtriser le problème du Fragile Base Class.   </p>
<p>Pour la mise en place, citons Herb Sutter, dans son article Virtuality :</p>
<ul>
<li>Prefer to make interfaces nonvirtual, using Template Method design pattern.</li>
<li>Prefer to make virtual functions private.</li>
<li>Only if derived classes need to invoke the base implementation of a virtual function, make the virtual function protected.</li>
<li>A base class destructor should be either public and virtual, or protected and nonvirtual.</li>
</ul>
<h4 id="un-mot-sur-patron-de-methode">Un mot sur Patron de Méthode</h4>
<p>Il est important d'insister sur le fait que NVI n'est pas la même chose que le patron de conception Patron de Méthode. En effet, la ressemblance est très forte sur le plan technique puisque ce patron de conception s'articule autour d'une interface définie ou redéfinie par les besoins concrets au niveau de sous-classes.</p>
<p>La principale différence provient des motivations : l'objectif d'un patron de conception Patron de Méthode est de proposer un découpage logique d'un algorithme ou d'un service en méthodes dont l'implémentation de certaines sera reléguée à des sous-classes concrètes, permettant de modifier l'algorithme selon diverses considérations sans pour autant risquer de changer la structure générale de l'algorithme.</p>
<h3 id="parametrage-par-politiques">Paramétrage par politiques</h3>
<h4 id="presentation">Présentation</h4>
<p>Le paramétrage par politique est une technique de programmation développée et démocratisée par Andrei Alexandrescu dans son livre Modern C++ Design: Generic Programming and Design Patterns Applied et dans la bibliothèque Loki dédiée à la méta-programmation en C++.    </p>
<p>Concrètement, il s'agit de profiter de l'héritage multiple et de la méta-programmation pour permettre de séparer les différents comportements d'une classe ou de plusieurs classes et de créer sur mesure des comportements en combinant plusieurs politiques.</p>
<h4 id="identification-des-politiques">Identification des politiques</h4>
<p>La clef d'un paramétrage par politique efficace réside dans l'analyse des différents comportements d'une classe ou d'un ensemble de classes. Imaginons que nous ayons à créer une bibliothèque de gestion de graphes. Un graphe peut être représenté sous différentes formes : matrice d'adjacence, matrice d'incidence , ou liste de successeurs. Chaque représentation à ses avantages et ses inconvénients en fonction des applications. On pourrait aisément créer 3 classes différentes mais cela ne serait pas très pertinent. On pourrait simplement templater la classe de graphe mais chaque type donné n'a pas la même API. De plus, imaginons qu'un graphe puisse être partagé entre plusieurs thread ou non selon les applications.  <br />
Sans paramétrage par politique, il faudrait un nombre de classes égales au nombre de facteurs de comportement multiplié par le nombre de modes par facteur. Cela apporterait évidemment du code redondant et une maintenabilité moindre puisque dans le cas d'un paramétrage par politique le but est d'isoler complètement un comportement. Pour modifier l'intégralité du modèle multithread d'une application, la modification d'une seule classe de politique est nécessaire.</p>
<p>Chaque facteur est représenté par une classe abstraite permettant de définir l'API commune à tous les modes et qui pourra être utilisée par les classes paramétrées avec ce facteur. Les classes concrètes implémentent chacun des modes de la politique.  <br />
Enfin, la classe de services qui doit être paramétrée par politique va être templatée avec chacune des politique et en hériter de manière publique ou privée selon les besoins.</p>
<p>Le mot clef pour distinguer les comportements d'une classe est l'orthogonalité. En effet, les politiques doivent être totalement orthogonale et de fait, être indépendantes. On perd tout l'intérêt, en terme de maintenabilité et de simplicité dans le cas où une politique dépend d'une autre.  <br />
Dans le cas de notre graphe, la représentation des données et son accès sont indépendants de la politique de multithread. C'est à la classe concrète de graphe d'utiliser ces deux politiques pour rendre ses services indépendamment des modes de politique choisis.</p>
<h4 id="mise-en-place">Mise en place</h4>
<p>La mise en place est aisée. Dans un premier temps, il suffit de définir des classes de politiques. Nous choisissons de créer une hiérarchie de classes pour chaque facteur.  <br />
Dans l'exemple évoqué à la section précédente, nous avons d'une part la politique relative au contexte parallèle et la politique relative à la représentation (et l'utilisation) des données du graphe.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThreadingModel</span> 
<span class="p">{</span>
<span class="k">protected</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Lock</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MultiThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ThreadingModel</span>
<span class="p">{</span>
<span class="k">protected</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Lock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MonoThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ThreadingModel</span>
<span class="p">{</span>
<span class="k">protected</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Lock</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// ... Autres modeles ...</span>
</pre></div>


<p>On définit la classe principale de graphe et on la paramétrise à l'instanciation selon les besoins :</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Rep</span> <span class="o">=</span> <span class="n">AdjacenceMatrix</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ThreadModel</span> <span class="o">=</span> <span class="n">MonoThread</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Graph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rep</span><span class="p">,</span> <span class="k">protected</span> <span class="n">ThreadModel</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="kt">bool</span> <span class="n">IsConnected</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="n">ThreadModel</span><span class="o">::</span><span class="n">Lock</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">Rep</span><span class="o">::</span><span class="n">IsConnected</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">GraphInciMT</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">&lt;</span><span class="n">IncidenceMatrix</span><span class="p">,</span> <span class="n">MultiThread</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span> <span class="n">GraphAdjMT</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">&lt;</span><span class="n">AdjacenceMatrix</span><span class="p">,</span> <span class="n">MultiThread</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Exemples</span>
<span class="n">Graph</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// Adjacence, MonoThread</span>
<span class="n">GraphInciMT</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// Incidence, MultiThread</span>
<span class="n">GraphAdjMT</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// Adjacence, MultiThread</span>
</pre></div>


<p>La classe Graph fait appelle à l'aveugle à sa politique de thread ainsi qu'à sa politique de représentation. La bonne écriture d'une politique est guidée par l'API de la classe abstraite en haut de la hiérarchie mais aucune vérification de type n'est effectuée par la classe Graph. Ainsi, un client pourrait écrire sa propre politique qui ne serait pas basée sur une des classes abstraites du code service.</p>
<p>La partie définissant les alias n'est pas du simple sucre syntaxique puisqu'il contribue également à la maintenabilité de l'application. L'utilisateur final utilise des types en dur, sans template, ce qui permet, si le besoin s'en fait sentir, de ne changer le template qu'à un unique endroit.</p>
<h3 id="combiner-les-deux-techniques">Combiner les deux techniques</h3>
<p>En observant attentivement l'exemple utilisant le paramétrage par politique, on se rend compte que le but de chaque politique est d'apporter un ensemble de services aux classes. On peut donc structurer nos hiérarchies de politiques en utilisant l'idiome NVI, leurs apportant tous les avantages cités précédemment.</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ThreadingModel</span> 
<span class="p">{</span>
<span class="k">protected</span> <span class="o">:</span>
    <span class="kt">void</span> <span class="n">Lock</span><span class="p">()</span> 
    <span class="p">{</span>
        <span class="n">Logger</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">this_thread</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; : acquisition du lock.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">_Lock</span><span class="p">();</span>
    <span class="p">}</span>

<span class="k">private</span> <span class="o">:</span> 
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_Lock</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MultiThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ThreadingModel</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">_Lock</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MonoThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ThreadingModel</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Lock</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span>
<span class="p">};</span>

<span class="c1">// ... Autres modeles ...</span>
</pre></div>


<p>Le reste ne change. Cependant, cela présente le désavantage de briser un des intérêts du NVI qui était de localiser les vérification des préconditions et des invariants à un seul endroit.<br />
En effet, l'utilisateur peut très bien écrire une classe de politique possédant l'interface requise par la classe paramétrée, sans respecter les invariants intrinsèques au service offert par la politique.</p>
<h4 id="limitation-du-type-de-politique">Limitation du type de politique</h4>
<p>Nous pouvons cependant forcer l'héritage de la classe de politique depuis la classe base de la hiérarchie par l'utilisation d'une assertion statique. Aucun overhead en runtime n'est à prévoir puisque l'assertion est statique.</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Rep</span> <span class="o">=</span> <span class="n">AdjacenceMatrix</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ThreadModel</span> <span class="o">=</span> <span class="n">MonoThread</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Graph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rep</span><span class="p">,</span> <span class="k">protected</span> <span class="n">ThreadModel</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>

    <span class="n">Graph</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_base_of</span><span class="o">&lt;</span><span class="n">ThreadModel</span><span class="p">,</span> <span class="n">ThreadingModel</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span> <span class="s">&quot;ThreadModel must inherit from ThreadingModel class&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>


<p>Le choix de la vérification basée sur l'interface ou celle plus stricte, basée sur l'interface et le type de la politique dépend du degré de liberté que vous souhaitez accorder à l'utilisateur. </p>
<h3 id="une-alternative">Une alternative</h3>
<p>Comme il m'a été fait remarqué, à la relecture de cet article, l'utilisation de classes virtuelles et de template a un effet certain sur les performances en plus de n'avoir qu'un avantage : l'utilisation de politiques dynamiques.</p>
<p>Il a alors été proposé une alternative intéressante, qui permet en outre, de n'effectuer la vérification que sur demande explicite :</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Policy</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">AssertChecker</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">Policy</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">service</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> 
        <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">42</span><span class="p">);</span>
        <span class="n">Policy</span><span class="o">::</span><span class="n">service</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Policy1</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">service</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Policy2</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">service</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Policy</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Concret</span> <span class="o">:</span> <span class="k">protected</span> <span class="n">Policy</span> <span class="p">{</span> <span class="p">....</span> <span class="p">};</span>

<span class="n">Concret</span><span class="o">&lt;</span><span class="n">Policy1</span><span class="o">&gt;</span> <span class="n">c1</span><span class="p">;</span> <span class="c1">// Sans vérification de contrat</span>
<span class="n">Concret</span><span class="o">&lt;</span><span class="n">AssertChecker</span><span class="o">&lt;</span><span class="n">Policy1</span><span class="o">&gt;&gt;</span> <span class="n">c1bis</span><span class="p">;</span> <span class="c1">// Avec vérification de contrat</span>
</pre></div>


<h3 id="allez-plus-loin-politique-de-base-a-la-construction-logicielle">Allez plus loin : politique de base à la construction logicielle</h3>
<p>Il peut parfois être intéressant, pour des questions de commodité, d'avoir une politique par défaut qui puisse être modifiée dans l'ensemble du logiciel lors de la compilation.  <br />
L'exemple le plus classique est celui de la politique du modèle de thread utilisée. En fonction de la machine sur laquelle va tourner le programme (ou des programmes utilisant la bibliothèque s'il s'agit d'une bibliothèque), on peut vouloir par défaut l'utilisation d'un unique thread et se passer de l'overhead généré par la protection des accès concurrents, ou alors au contraire utiliser l'ensemble de cœurs disponibles, choisir le mode de parallélisme (thread standards ou OpenMP par exemple, voire MPI), etc.</p>
<p>Évidemment, on veut toujours pouvoir redéfinir localement la politique pour des raisons diverses et variées (dans notre exemple, l'utilisateur peut juger que localement il n'est pas nécessaire d'utiliser un modèle parallèle car il y aurait un overhead trop important sur une instance donnée).</p>
<p>Pour se faire on peut envisager la définition d'une constante via le préprocesseur et la définition d'un alias permettant d'avoir un vrai type à passer en paramètre comme politique :</p>
<div class="highlight"><pre><span></span><span class="cp">#ifndef DEFAULT_THREADING_MODEL</span>
<span class="cp">#define DEFAULT_THREADING_MODEL MultiThread</span>

<span class="cp">#ifndef DEFAULT_GRAPH_DATA</span>
<span class="cp">#define DEFAULT_GRAPH_DATA AdjacenceMatrix</span>

<span class="k">using</span> <span class="n">DefThreadingPolicy</span> <span class="o">=</span> <span class="n">DEFAULT_THREADING_MODEL</span><span class="p">;</span>
<span class="k">using</span> <span class="n">DefGraphDataPolicy</span> <span class="o">=</span> <span class="n">DEFAULT_GRAPH_DATA</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Rep</span> <span class="o">=</span> <span class="n">DefGraphDataPolicy</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ThreadModel</span> <span class="o">=</span> <span class="n">DefThreadingPolicy</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Graph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rep</span><span class="p">,</span> <span class="k">protected</span> <span class="n">ThreadModel</span>
<span class="p">{</span> <span class="p">}</span>
</pre></div>


<p>Cela n'empêche en rien d'utiliser des alias spécialisant les templates comme vu précédemment.</p>
<p>Il suffit ainsi de redéfinir le constante souhaitée au moment de la compilation :</p>
<div class="highlight"><pre><span></span>g++ -DDEFAULT_THREADING_MODEL=MonoThread ...
</pre></div>


<h2 id="conclusion">Conclusion</h2>
<p>Comme n'importe quel patron de conception et autre technique de conception, l'utilisation du NVI ou du paramétrage par politique ne doit pas être systématique mais faire l'objet d'une motivation réelle vis à vis d'une situation où elle est pertinente. <br />
Ces situations n'ont pas été décrites en détail puisqu'il est impossible d'en dresser une liste exhaustive : l'important est d'identifier les situations où leur utilisation est bénéfique ou résout un problème donné.</p>
<p>L'utilisation stricto sensu des deux techniques combinées présente le désavantage d'un surcoût naturel lié à l'utilisation de méthodes virtuelles avec des templates ce qui peut être rebutant. Cette utilisation n'est intéressante que dans le cas où l'on veut absolument maintenir la consistance d'une hiérarchie de classes de politique. Dans les autres cas, il est certainement plus intéressant d'utiliser l'alternative proposée.    </p>
<p>J'espère que cet article vous aura donné les grandes lignes permettant de justifier l'utilisation du NVI et du paramétrage par politique, ainsi que quelques idées pour combiner les deux et faciliter la vie aux utilisateurs de votre code.</p>
        </div>
    </section>
        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">

        <!-- Search bar in low width mode -->
        <li id="searchSideBar" class="list-group-item"><span>
                <form class="navbar-search" action="/blog/search">
                  <input type="text" class="search-query" placeholder="Rechercher" name="q" id="tipue_search_input" required>
                </form></span>
        </li>

        <li class="list-group-item"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Social</span></h4>
              <ul class="list-group" id="social">
                    <li class="list-group-item"><a href="https://example.org">
                        <i class="fa fa-comment fa-lg"></i>
                       Link 1</a>
                    </li>
                    <li class="list-group-item"><a href="https://example.org">
                        <i class="fa fa-comments fa-lg"></i>
                       Link 2</a>
                    </li>
                    <li class="list-group-item"><a href="/page/content">
                        <i class="fa fa-etc fa-lg"></i>
                       etc</a>
                    </li>
              </ul>
            </li>


            <li class="list-group-item"><a href="https://yliesc.github.io/"><h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Categories</span></h4></a>
                <ul class="list-group" id="categories">
                </ul>
            </li>



    <li class="list-group-item"><h4><i class="fa fa-link fa-lg"></i><span class="icon-label">External Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="https://example.org" target="_blank">
                Link 1
            </a>
        </li>
        <li class="list-group-item">
            <a href="https://example.org" target="_blank">
                Link 2
            </a>
        </li>
        <li class="list-group-item">
            <a href="/page/content" target="_blank">
                etc
            </a>
        </li>
      </ul>
    </li>

        <li class="list-group-item" id="github">
            <ul class="list-group">
                <li class="list-group-item"><h5>Vous voyez une erreur ?</h5></li>
                <li class="list-group-item">
                    <a class="btn btn-info github" target="_blank" href="https://github.com/YliesC/website/edit/master/content/pages/pdp/content/idiome-nvi-parametrage-par-politique-en-c.md">
                        <i class="fa fa-random"></i> Modifiez la page sur GitHub
                    </a>
                </li>
            </ul>
        </li>
    </ul>
</section>            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy;  
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
<a href="http://getbootstrap.com" target="_blank">Bootstrap</a>                <p><small>  <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.fr"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-sa/4.0/80x15.png" /></a>
    Content
  licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.fr">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://yliesc.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://yliesc.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://yliesc.github.io/theme/js/respond.min.js"></script>

<!--  -->


</body>
</html>